<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="prod-FunctionCall">
   <description>Tests for the FunctionCall production.
    Contains tests verifying the function calling mechanism; not a particular function implementation.</description>
   <link type="spec" document="http://www.w3.org/TR/xquery-30/"
         idref="doc-xquery30-FunctionCall"/>
         
   <environment name="ListUnionTypes">
      <schema uri="http://www.w3.org/XQueryTest/ListUnionTypes" file="ValidateExpr/listunion.xsd">
         <description>A schema defining a list of unions.</description>
         <created by="Anonymous" on="2006-06-07"/>
      </schema>
   </environment>      
         
   <test-case name="FunctionCall-001">
      <description>Test that arguments are atomized - built in function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[concat(<a>X</a>, <a>Y</a>)]]></test>
      <result>
        <assert-string-value>XY</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-002">
      <description>Test that arguments are atomized - constructor function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[xs:boolean(<a>0</a>)]]></test>
      <result>
        <assert-false/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-003">
      <description>Test that arguments are atomized - constructor function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[xs:integer(validate type xs:decimal {<a>93.7</a>})]]></test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>93</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-004">
      <description>Test that arguments are atomized - user-defined function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
         declare function local:f($in as xs:boolean) as xs:boolean { $in };
         local:f(<a>0</a>)]]></test>
      <result>
        <assert-false/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-005">
      <description>Test that arguments are atomized - user-defined function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:f($in as xs:anyAtomicType) as xs:boolean { $in instance of xs:decimal };
         local:f(validate type xs:integer {<a>12</a>})]]></test>
      <result>
        <assert-true/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-006">
      <description>Test that arguments are atomized - anonymous inline function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
         let $f := function ($in as xs:boolean) as xs:boolean { $in }
         return $f(<a>0</a>)
      ]]></test>
      <result>
        <assert-false/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-007" covers="dynamic-function-call">
      <description>Test that arguments are atomized - dynamic call to a user-defined function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:f($in as xs:anyAtomicType) as xs:boolean { $in instance of xs:decimal };
         let $f := function-lookup(xs:QName('local:f'), 1)
         return $f(validate type xs:integer {<a>12</a>})]]></test>
      <result>
        <assert-true/>
      </result>
   </test-case>
   
  <test-case name="FunctionCall-008" covers="dynamic-function-call">
      <description>Test that arguments are atomized - dynamic call to a constructor function</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
        let $f := xs:integer#1
        return $f(validate type xs:decimal {<a>93.7</a>})
      ]]></test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>93</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-009">
      <description>Test that a sequence of untypedAtomic values is cast to the target type: user-defined function.
         Also tests XPath 3.0 inline functions, casting to list, and bang operator.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        declare function local:f($in as xs:decimal*) as xs:decimal {sum($in, 0.0)};
        local:f(xs:NMTOKENS('1 1.2 1.3 1.4')!xs:untypedAtomic(.))
      ]]></test>
      <result>
        <all-of>
          <assert-type>xs:decimal</assert-type>
          <assert-eq>4.9</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-010">
      <description>Test that a sequence of untypedAtomic values is cast to the target type: inline function.
         Also tests XPath 3.0 inline functions, casting to list, and bang operator.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>function($in as xs:decimal*) as xs:decimal {sum($in, 0.0)}(xs:NMTOKENS('1 1.2 1.3 1.4')!xs:untypedAtomic(.))</test>
      <result>
        <all-of>
          <assert-type>xs:decimal</assert-type>
          <assert-eq>4.9</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-011">
      <description>Test that a sequence of untypedAtomic values is cast to the target type: built-in function.
         Also tests casting to list, and bang operator.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>codepoints-to-string(xs:NMTOKENS('48 49 50 51')!xs:untypedAtomic(.))</test>
      <result>
        <all-of>
          <assert-type>xs:string</assert-type>
          <assert-string-value>0123</assert-string-value>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-012" covers="cast-to-list">
      <description>Test that a sequence of NON-untypedAtomic values is NOT cast to the target type: built-in function.
         Also tests casting to list.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>codepoints-to-string(xs:NMTOKENS('30 31 32 33'))</test>
      <result>
        <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-013">
      <description>Test that the untypedAtomic result of a user-defined function is cast to the declared type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        declare function local:f($a as xs:integer, $b as xs:integer) as xs:integer {
          data(<a>{$a}{$b}</a>)
        };
        local:f(12, 34)
      ]]></test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>1234</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-014">
      <description>Test that the untypedAtomic result of an inline function is cast to the declared type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[
        let $f := function($a as xs:integer, $b as xs:integer) as xs:integer {
          data(<a>{$a}{$b}</a>)
        }
        return $f(12, 34)
      ]]></test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>1234</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-015">
      <description>Test that arguments are atomized - but not the argument of casting to QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <modified by="O'Neil Delpratt" on="2012-08-08" change="fix bug 14873"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:f($in as xs:integer) as xs:integer { $in + 1 };
         let $f := function-lookup(xs:QName(<f>local:f</f>), 1)
         return $f(12)]]></test>
      <result>
        <assert-eq>13</assert-eq>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-016">
      <description>Test that untyped arguments are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:f($in as xs:QName) as xs:integer { string-length(local-name-from-QName($in)) };
         let $e := <a xsi:type='my:integer' xmlns:my='http://my.example.com/'>123</a>
         return local:f($e/@xsi:type)]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-017">
      <description>Test that untyped arguments are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         let $f := function ($in as xs:QName) as xs:integer { string-length(local-name-from-QName($in)) }
         let $e := <a xsi:type='my:integer' xmlns:my='http://my.example.com/'>123</a>
         return $f($e/@xsi:type)
      ]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-018">
      <description>Test that untyped arguments are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         let $e := <a xsi:type='my:integer' xmlns:my='http://my.example.com/'>123</a>
         return local-name-from-QName($e/@xsi:type)]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-019">
      <description>Test that untyped results are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:q ($prefix as xs:string, $local as xs:string) as xs:QName {
            <a>{$prefix}:{$local}</a>
         };
         local:q('fn', 'abs')
      ]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-020">
      <description>Test that untyped results are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         let $q := function ($prefix as xs:string, $local as xs:string) as xs:QName {
            <a>{$prefix}:{$local}</a>
         }
         return $q('fn', 'abs')
      ]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-021">
      <description>Test that untyped results are converted - but not when the expected type is QName</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
         declare function local:q ($prefix as xs:string, $local as xs:string) as xs:QName {
            <a>{$prefix}:{$local}</a>
         };
         let $curried := local:q('fn', ?)
         return $curried('abs')
      ]]></test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   

   
   <test-case name="FunctionCall-023">
      <description>Test that a sequence of arguments is atomized</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[string-join((<a>X</a>, <a>Y</a>, <a>Z</a>), '')]]></test>
      <result>
        <assert-string-value>XYZ</assert-string-value>
      </result>
   </test-case>
   

   <test-case name="FunctionCall-025">
      <description>Test that a sequence of numeric values undergoes numeric promotion to the target type.
         Also tests XPath 3.0 inline functions.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>function($in as xs:double*) as xs:double {sum($in, 0.0e0)}((1, xs:float(0.25), xs:decimal(0.5)))</test>
      <result>
        <all-of>
          <assert-type>xs:double</assert-type>
          <assert-eq>1.75</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-026">
      <description>Test that a sequence of anyURI values undergoes numeric promotion to the target type.
         Also tests XPath 3.0 inline functions.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>function($in as xs:string*) as xs:string {string-join($in, ';')}((xs:anyURI('http://one.com/'), xs:anyURI('http://two.com/')))</test>
      <result>
        <all-of>
          <assert-type>xs:string</assert-type>
          <assert-string-value>http://one.com/;http://two.com/</assert-string-value>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-027">
      <description>Test that an untypedAtomic value is NOT cast to the target type where the target type is a list type.
         This is an error because although casting to a list type is allowed, a list type cannot be used in a function signature.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <dependency type="spec" value="XP30+"/>
      <test>function($in as xs:NMTOKENS) as item()* {$in}(xs:untypedAtomic('abc def'))</test>
      <result>
        <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-028">
      <description>Test that the target type can be a union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:unionType) as xs:boolean {$in instance of xs:integer}(23)</test>
      <result>
        <assert-true/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-029">
      <description>Test that the target type can be a union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:unionType) as xs:boolean {$in instance of xs:integer}(xs:float(12))</test>
      <result>
        <assert-false/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-030">
      <description>Test that numeric promotion does not occur when the target type is a union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:unionType) as xs:boolean {$in instance of xs:integer}(12.3)</test>
      <result>
        <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-031">
      <description>Test that casting of untypedAtomic does occur when the target type is a union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:unionType) as xs:boolean {$in instance of xs:integer}(xs:untypedAtomic('123'))</test>
      <result>
        <assert-true/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-032">
      <description>Test that the argument type cannot be a union type having a list type in its membership.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:unionOfListType) as xs:boolean {$in instance of xs:integer}(23)</test>
      <result>
        <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-033">
      <description>Test that the argument type cannot be a union type derived by restriction from another union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:restrictedUnionType) as xs:boolean {$in instance of xs:integer}(23)</test>
      <result>
        <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-034">
      <description>Test that the argument type cannot be a list type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as lu:listType) as xs:boolean {$in instance of xs:integer}(23)</test>
      <result>
        <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-035">
      <description>Test that the result type can be a union type and that the return value can be a member of the union.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function($in as xs:integer) as lu:unionOfUnionType {$in + 23}(9)</test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-string-value>32</assert-string-value>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-036">
      <description>Test that the result type can be a union type and that the return value can be a member of the union.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	declare function local:daysAhead($in as xs:integer) as lu:unionOfUnionType {current-date() + (xs:dayTimeDuration('P1D')*$in)};
      	local:daysAhead(9)
      </test>
      <result>
        <assert-type>xs:date</assert-type>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-037">
      <description>Test that the result type can be a union type and that the return value can be cast to the union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	declare function local:makeDate($in as xs:string) as lu:unionOfUnionType {
      	  if ($in castable as xs:date)
      	  then xs:untypedAtomic($in)
      	  else current-date()
      	};
      	local:makeDate('2012-12-12')
      </test>
      <result>
        <assert-type>xs:date</assert-type>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-038" covers="partial-function-application">
      <description>Test that the result type can be a union type and that the return value can be cast to the union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	declare function local:makeDate($in as xs:string, $year as xs:integer) as lu:unionOfUnionType {
      	  let $date := $year || '-' || $in
      	  return if ($date castable as xs:date)
      	         then xs:untypedAtomic($date)
      	         else current-date()
      	};
      	let $make2012date := local:makeDate(?, 2012)
      	return $make2012date('12-12')
      </test>
      <result>
        <all-of>
          <assert-type>xs:date</assert-type>
          <assert-string-value>2012-12-12</assert-string-value>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-039">
      <description>Test that the result type cannot be a union type derived by restriction from another union.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	function() as lu:restrictedUnionType {23}()</test>
      <result>
        <error code="XPST0051"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-040">
      <description>Test that the result type can be a namespace-sensitive union type.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test><![CDATA[
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	let $f := function() as lu:namespaceSensitiveUnionType {node-name(<a/>)}
      	return local-name-from-QName($f())
      ]]></test>
      <result>
        <assert-string-value>a</assert-string-value>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-041">
      <description>Test that if the result type is a namespace-sensitive union type, casting from untypedAtomic is not allowed.</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
      	let $f := function() as lu:namespaceSensitiveUnionType {xs:untypedAtomic('xsi:type')}
      	return local-name-from-QName($f())</test>
      <result>
        <error code="XPTY0117"/>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-042">
      <description>Test that Union(A, B) is substitutable for A as a function argument type</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        declare function local:hof($f as function(xs:integer) as xs:integer) as xs:integer {$f(3) + 1};
      	let $f := function($a as lu:unionType) as xs:integer {$a + 2}
      	return local:hof($f)</test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>6</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="FunctionCall-043">
      <description>Test that Union(Union(A, B), c) is substitutable for Union(A, B) as a function argument type</description>
      <created by="Michael Kay" on="2011-10-31"/>
      <environment ref="ListUnionTypes"/>
      <dependency type="spec" value="XQ30+"/>
      <dependency type="feature" value="schemaImport"/>
      <test>
        declare namespace lu = 'http://www.w3.org/XQueryTest/ListUnionTypes' ;
        import schema "http://www.w3.org/XQueryTest/ListUnionTypes";
        declare function local:hof($f as function(lu:unionType) as xs:integer) as xs:integer {$f(3) + 1};
      	let $f := function($a as lu:unionOfUnionType) as xs:integer {$a + 2}
      	return local:hof($f)</test>
      <result>
        <all-of>
          <assert-type>xs:integer</assert-type>
          <assert-eq>6</assert-eq>
        </all-of>
      </result>
   </test-case>
   
   <test-case name="K-FunctionCallExpr-1">
      <description> A test whose essence is: `func-does-not-exist(1, 2, 3)`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>func-does-not-exist(1, 2, 3)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-2">
      <description> A test whose essence is: `fn:func-does-not-exist(1, 2, 3)`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>fn:func-does-not-exist(1, 2, 3)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-3">
      <description> A test whose essence is: `xs:func-does-not-exist(1, 2, 3)`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>xs:func-does-not-exist(1, 2, 3)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-4">
      <description> A test whose essence is: `local:func-does-not-exist(1, 2, 3)`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test>local:func-does-not-exist(1, 2, 3)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-5">
      <description> A test whose essence is: `prefix-does-not-exist:func-does-not-exist(1, 2, 3)`. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>prefix-does-not-exist:func-does-not-exist(1, 2, 3)</test>
      <result>
         <error code="XPST0081"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-6">
      <description> A function call containing an invalid QName as name. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>f:f:()</test>
      <result>
         <any-of>
            <error code="XPST0003"/>
            <error code="XPST0081"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-7">
      <description> A function call containing an invalid QName as name. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>:f()</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-8">
      <description> A function call containing an invalid QName as name. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>:f()</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-9">
      <description> A function call containing an invalid QName as name. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>1fd()</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-10">
      <description> A function call containing an invalid QName as name. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>p:f:lname()</test>
      <result>
         <any-of>
            <error code="XPST0003"/>
            <error code="XPST0081"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-11">
      <description> No function by name fn:document() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>document("example.com/file.ext")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-12">
      <description> No function by name fn:unparsed-text() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Tim Mills" on="2012-03-29" change="Added dependency on XP20/XQ10.  Removed possible result 'XTDE1170'"/>
      <dependency type="spec" value="XP20 XQ10"/>
      <test>unparsed-text("example.com/file.ext")</test>
      <result>
	<error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-13">
      <description> No function by name fn:unparsed-text() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Tim Mills" on="2012-03-29" change="Added dependency on XP20/XQ10.  Removed possible result 'false'"/>
      <dependency type="spec" value="XP20 XQ10"/>
      <test>unparsed-text-available("example.com/file.ext")</test>
      <result>
	<error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-14">
      <description> No function by name fn:key() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>key('func', "a value")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-15">
      <description> No function by name fn:format-number() exists in XQuery 1.0 (although one does in XSLT and in XQuery 3.0). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-11-17" change="fix bug 14855"/>
      <dependency type="spec" value="XQ10 XP20"/>      
      <test>format-number(3, "0000")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>
   
   <test-case name="K-FunctionCallExpr-15a">
      <description> No function by name fn:format-number() exists in XQuery 1.0 (although one does in XSLT and in XQuery 3.0). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-11-17" change="fix bug 14855"/>
      <modified by="Michael Kay" on="2011-11-25" change="correct the version dependency"/>
      <dependency type="spec" value="XQ30 XP30"/>      
      <test>format-number(3, "0000")</test>
      <result>
         <assert-eq>"0003"</assert-eq>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-16">
      <description> No function by name fn:format-time() exists in XQuery 1.0 (although one does in XSLT). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-05-21" change="make results repeatable"/>
      <modified by="Michael Kay" on="2011-11-17" change="split into XQ10 and XQ30 tests"/>
      <dependency type="spec" value="XQ10 XP20"/>
      <test>matches(format-time(current-time(), "[H01]:[m01]"), "[0-2][0-9]:[0-5][0-9]")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>
   
   <test-case name="K-FunctionCallExpr-16a">
      <description> No function by name fn:format-time() exists in XQuery 1.0 (although one does in XSLT). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-05-21" change="make results repeatable"/>
      <modified by="Michael Kay" on="2011-11-17" change="split into XQ10 and XQ30 tests"/>
      <dependency type="spec" value="XQ30+ XP30+"/>
      <test>matches(format-time(current-time(), "[H01]:[m01]"), "[0-2][0-9]:[0-5][0-9]")</test>
      <result>
      	<assert-true/>
      </result>
   </test-case>
   
    <test-case name="K-FunctionCallExpr-17">
      <description> No function by name fn:format-time() exists in XQuery 1.0 (although one does in XSLT). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-05-21" change="make results repeatable"/>
      <modified by="Michael Kay" on="2011-11-17" change="split into XQ10 and XQ30 tests"/>
      <dependency type="spec" value="XQ10 XP20"/>
      <test>matches(format-time(current-time(), "[H01]:[m01]", (), (), ()), "..:..")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>
   
   <test-case name="K-FunctionCallExpr-17a">
      <description> No function by name fn:format-time() exists in XQuery 1.0 (although one does in XSLT). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="Michael Kay" on="2011-05-21" change="make results repeatable"/>
      <modified by="Michael Kay" on="2011-11-17" change="split into XQ10 and XQ30 tests"/>
      <dependency type="spec" value="XQ30+ XP30+"/>
      <test>matches(format-time(current-time(), "[H01]:[m01]", (), (), ()), "..:..")</test>
      <result>
      	<assert-true/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-18">
      <description> No function by name fn:format-date() exists in XQuery 1.0 (although one does in XSLT and XQuery 1.1). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]"), "[0-9]{4}-[0-9]{2}-[0-9]{2}")</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0017"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-19">
      <description> No function by name fn:format-dateTime() exists in XQuery 1.0 (although one does in XSLT and XQuery 1.1). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>matches(format-dateTime(current-dateTime(), "[Y0001]-[M01]-[D01]", (), (), ()), "....-..-..")</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0017"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-20">
      <description> No function by name fn:format-dateTime() exists in XQuery 1.0 (although one does in XSLT and XQuery 1.1). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]"), "[0-1][0-9]/[0-3][0-9]/[0-9]{4} at [0-9]{2}:[0-9]{2}:[0-9]{2}")</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0017"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-21">
      <description> No function by name fn:format-dateTime() exists in XQuery 1.0 (although it does exist in XSLT and XQuery 1.1). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>matches(format-dateTime(current-dateTime(), "[M01]/[D01]/[Y0001] at [H01]:[m01]:[s01]", (), (), ()), "../../.... at ..:..:..")</test>
      <result>
         <any-of>
            <assert-true/>
            <error code="XPST0017"/>
         </any-of>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-22">
      <description> No function by name fn:current() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>current()</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-23">
      <description> No function by name fn:unparsed-entity-uri() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>unparsed-entity-uri("example.com/file.ext")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-24">
      <description> No function by name fn:unparsed-entity-public-id() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>unparsed-entity-public-id("entity")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-25">
      <description> No function by name fn:generate-id() exists(although one does in XSLT). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10"/>
      <test><![CDATA[generate-id(<a/>) castable as xs:NCName]]></test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>
   
   <test-case name="K-FunctionCallExpr-25a">
      <description> Function by name fn:generate-id() does exist in XQuery 3.0. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ30+"/>
      <test><![CDATA[generate-id(<a/>) castable as xs:NCName]]></test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-26">
      <description> No function by name fn:system-property() exists(although one does in XSL-T). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>system-property("xsl:vendor")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-27">
      <description> No function by name fn:escape-uri() exists(although one did in older 'Functions &amp; Operators' drafts). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>fn:escape-uri("http:/example.com/")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K-FunctionCallExpr-28">
      <description> No function by name fn:sub-sequence() exists(although one by name fn:subsequence does). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>fn:sub-sequence("http:/example.com/", 1, 1)</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-1">
      <description> Two user functions with many arguments. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test>
        declare function local:bar($c, $d, $e, $f, $g, $h, $i, $j, $a, $b) { 1 }; 
        declare function local:moo($k) { $k }; 
        local:moo(1)</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-2">
      <description> Function current-grouping-key() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>current-grouping-key()</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-3">
      <description> Function current() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>current()</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-4">
      <description> Function unparsed-entity-uri() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>unparsed-entity-uri("str")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-5">
      <description> Function unparsed-entity-public-id() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>unparsed-entity-public-id("str")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-6">
      <description> Function generate-id() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="O'Neil Delpratt" on="2012-05-22" change="Bug fix related to bug #14854: Added dependency"/>
      <dependency type="spec" value="XP20 XQ10"/>
      <test>generate-id("str")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-7">
      <description> Function generate-id() is not available in XQuery(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <modified by="O'Neil Delpratt" on="2012-05-22" change="Bug fix related to bug #14854: Added dependency"/>
      <dependency type="spec" value="XP20 XQ10"/>
      <test>generate-id()</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-8">
      <description> Function system-property() is not available in XQuery(#2). </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>system-property("property")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-9">
      <description> Function key() is not available in XQuery. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <test>key("id")</test>
      <result>
         <error code="XPST0017"/>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-10">
      <description> Check that nodes, when passed through function arguments, have proper node identities. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test><![CDATA[
        declare variable $a := <a/>; 
        declare function local:testSingleNodeIdentity($node as node()) { $node is $node }; 
        declare function local:testDoubleNodeIdentity($a as node(), $b as node()) { $a is $b }; 
        local:testSingleNodeIdentity(<a/>), local:testDoubleNodeIdentity(<a/>, <b/>), local:testDoubleNodeIdentity($a, $a)
      ]]></test>
      <result>
         <assert-string-value>true false true</assert-string-value>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-11">
      <description> A very simple string-difference function. </description>
      <created by="Frans Englich" on="2007-11-26"/>
      <dependency type="spec" value="XQ10+"/>
      <test>
        declare function local:compare($arg1 as xs:string, $arg2 as xs:string) { 
            let $cps1 := string-to-codepoints($arg1), 
            $cps2 := string-to-codepoints($arg2) 
            return abs(count($cps1) - count($cps2)) + sum(for $x in 1 to min((count($cps1), count($cps2))) 
                                                          return if ($cps1[$x] ne $cps2[$x]) then 1 else ()) }; 
        local:compare("", ""), 
        local:compare("a", ""), 
        local:compare("", "a"), 
        local:compare("a", "a"), 
        local:compare("", "aa"), 
        local:compare("aa", "ab"), 
        local:compare("ba", "ba"), 
        local:compare("bab", "bbb"), 
        local:compare("aba", "bab")
     </test>
      <result>
         <assert-string-value>0 1 1 0 2 1 0 1 3</assert-string-value>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-12">
      <description> Trigger an infinite recursion in one implementation. </description>
      <created by="Frans Englich" on="2008-05-08"/>
      <dependency type="spec" value="XQ10+"/>
      <test>
        declare function local:func1() { if(local:func2('b')) then 3 else local:func1() }; 
        declare function local:func2($a) { if(matches("",$a)) then () else 4 }; 
        local:func1()</test>
      <result>
         <assert-eq>3</assert-eq>
      </result>
   </test-case>

   <test-case name="K2-FunctionCallExpr-13">
      <description> Have a function which recurses infintely, but which never is called. </description>
      <created by="Frans Englich" on="2008-11-13"/>
      <dependency type="spec" value="XQ10+"/>
      <test>declare function local:foo($arg) { local:foo(local:foo(1)) }; 1</test>
      <result>
         <assert-eq>1</assert-eq>
      </result>
   </test-case>
</test-set>
