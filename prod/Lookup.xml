<?xml version="1.0" encoding="UTF-8"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="prod-Lookup" covers="postfix-lookup">
   <description>Tests for the Binary Lookup operator on maps and arrays in XQuery 3.1</description>
             

   <test-case name="Lookup-001">
      <description>Integer subscript into an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])[.?1 eq 'c']</test>
      <result>
         <assert-deep-eq>['c', 'd']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-002">
      <description>Variable subscript into an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $i := 1 return (['a', 'b'], ['c', 'd'])[.?($i) eq 'c']</test>
      <result>
         <assert-deep-eq>['c', 'd']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-003">
      <description>Integer subscript into an array: leading zeroes allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])[ .? 001 eq 'c']</test>
      <result>
         <assert-deep-eq>['c', 'd']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-004">
      <description>Integer subscript into an array: minus sign not allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])[ .? -1 eq 'c']</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-005">
      <description>Integer subscript into an array: array index too low</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])[ .?0 eq 'c']</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-006">
      <description>Integer subscript into an array: array index too high</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'], ['e'])[ .?2 eq 'b']</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-007">
      <description>Integer subscript into an array: range of subscripts</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?(1 to 2) = 'b']</test>
      <result>
         <assert-deep-eq>['a', 'b', 'c'], ['b', 'c', 'd']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-008">
      <description>Integer subscript into an array: variable range of subscripts</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($i) = 'b']</test>
      <result>
         <assert-deep-eq>['b', 'c', 'd'], ['e', 'f', 'b']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-009">
      <description>Name lookup into an array: type error</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?first = 'b']</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-010">
      <description>Variable lookup into an array: type error</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?($d) = 'b']</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-011">
      <description>Binary lookup with no context item</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>let $d := function($x) {$x + .?2} return $d(12)</test>
      <result>
         <error code="XPDY0002"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-012">
      <description>Binary lookup when context item is not an array or map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(1 to 10)[.?1 = 3]</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-013">
      <description>Binary lookup when context item is a function but not an array or map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>(floor#1, ceiling#1, round#1, abs#1)[.?1 = 1]</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-014">
      <description>Binary lookup selecting all items of an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[ .?* = 'c']</test>
      <result>
         <assert-deep-eq>['a', 'b', 'c'], ['b', 'c', 'd']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-015">
      <description>Result of Binary lookup is atomized</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>([1, [2], [3]], [[2], 2, [4]])[ .?1 = .?2 ]</test>
      <result>
         <assert-deep-eq>[[2], 2, [4]]</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-016">
      <description>No syntactic confusion with place-markers</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(.?1, ?, 'http://www.w3.org/2005/xpath-functions/collation/codepoint')('a')]</test>
      <result>
         <assert-deep-eq>['a', 'b', 'c']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-017">
      <description>No syntactic confusion with place-markers</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[contains(.?1, ?)('a')]</test>
      <result>
         <assert-deep-eq>['a', 'b', 'c']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-018">
      <description>Decimal literal not allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?1.0 = 'a']</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-019">
      <description>Decimal literal not allowed in parentheses</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?(1.0) = 'a']</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-020">
      <description>Subscript is atomized</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XQ31+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
        let $x := (validate type xs:integer {<x>1</x>}, validate type xs:integer {<y>2</y>}) return
        (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?($x) = 'b']
      ]]></test>
      <result>
         <assert-deep-eq>(['a', 'b', 'c'], ['b', 'c', 'd'])</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-021">
      <description>Subscript is atomized, and untypedAtomic is converted to xs:integer</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XQ31+"/>
      <test><![CDATA[
        let $x := (<x>1</x>, <y>2</y>) return
        (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[.?($x) = 'b']
      ]]></test>
      <result>
         <assert-deep-eq>(['a', 'b', 'c'], ['b', 'c', 'd'])</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-022">
      <description>Filtering a sequence of arrays produced using ?*</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*[.?1 = 'a']</test>
      <result>
         <assert-deep-eq>['a', 'b', 'c']</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-023">
      <description>Binary lookup on rhs of "!"</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]!.?*!.?1</test>
      <result>
         <assert-deep-eq>'a', 'b', 'e'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-024">
      <description>Binary lookup on rhs of "/". Must fail because context item can only be a node.</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XQ31+"/>
      <test><![CDATA[
        let $x := (<x>1</x>, <y>2</y>) return $x / .?1
      ]]></test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-025">
      <description>Select nothing from an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])[exists(.?())]</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-040">
      <description>Lookup by name in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})[.?b eq 3]</test>
      <result>
         <assert-deep-eq>map{'a':2, 'b':3, 'c':4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-041">
      <description>Lookup by number in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?2 eq 3]</test>
      <result>
         <assert-deep-eq>map{1:2, 2:3, 3:4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-042">
      <description>Lookup by range of values in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?(1 to 2) = 3]</test>
      <result>
         <assert-deep-eq>map{1:2, 2:3, 3:4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-043">
      <description>Lookup by hyphenated name in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.?b-1 eq 3]</test>
      <result>
         <assert-deep-eq>map{'a-1':2, 'b-1':3, 'c-1':4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-044">
      <description>Comment appearing after ".?"</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})[.? (:confusing.?:) b-1 eq 3]</test>
      <result>
         <assert-deep-eq>map{'a-1':2, 'b-1':3, 'c-1':4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-045">
      <description>Get all entries in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[.?* = 3]</test>
      <result>
         <assert-deep-eq>map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4}</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-046">
      <description>Select nothing from a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})[exists(.?())]</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>

   <test-case name="Lookup-101">
      <description>Integer subscript into an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])?1</test>
      <result>
         <assert-deep-eq>'a', 'c'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-102">
      <description>Variable subscript into an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $i := 1 return (['a', 'b'], ['c', 'd'])?($i)</test>
      <result>
         <assert-deep-eq>'a', 'c'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-103">
      <description>Integer subscript into an array: leading zeroes allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])? 001</test>
      <result>
         <assert-deep-eq>'a', 'c'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-104">
      <description>Integer subscript into an array: minus sign not allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])? -1</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-105">
      <description>Integer subscript into an array: array index too low</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'])?0</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-106">
      <description>Integer subscript into an array: array index too high</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b'], ['c', 'd'], ['e'])?2</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-107">
      <description>Integer subscript into an array: range of subscripts</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1 to 2)</test>
      <result>
         <assert-deep-eq>'a', 'b', 'b', 'c', 'e', 'f'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-108">
      <description>Integer subscript into an array: variable range of subscripts</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $i := (1, 3) return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($i)</test>
      <result>
         <assert-deep-eq>'a', 'c', 'b', 'd', 'e', 'b'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-109">
      <description>Name lookup into an array: type error</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']) ?first</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-110">
      <description>Variable lookup into an array: type error</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $d := current-date() return (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($d)</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-111">
      <description>Binary lookup with no context item</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>let $d := function($x) {$x?2} return $d([12, 13])</test>
      <result>
         <assert-eq>13</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-112">
      <description>Binary lookup when lhs is not an array or map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(1 to 10)?1</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-113">
      <description>Binary lookup when lhs is a function but not an array or map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>(floor#1, ceiling#1, round#1, abs#1)?1</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-114">
      <description>Binary lookup selecting all items of an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?*</test>
      <result>
         <assert-deep-eq>'a', 'b', 'c', 'b', 'c', 'd', 'e', 'f', 'b'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-115">
      <description>Result of Binary lookup is atomized</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>([1, [2], [3]], [[2], 2, [4]])?3 = 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="Lookup-116">
      <description>No syntactic confusion with occurrence indicators (syntax error, treat as is not a primary)</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>['a', 'b', 'c'] treat as array(*)??1</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-117">
      <description>No syntactic confusion with occurrence indicators</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>['a', 'b', 'c'] treat as array(*) ? 1</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-118">
      <description>Decimal literal not allowed</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?1.0 </test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-119">
      <description>Decimal literal not allowed in parentheses</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?(1.0) </test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-120">
      <description>Subscript is atomized</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XQ31+"/>
      <dependency type="feature" value="schemaValidation"/>
      <test><![CDATA[
        let $x := (validate type xs:integer {<x>1</x>}, validate type xs:integer {<y>2</y>}) return
        (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($x)
      ]]></test>
      <result>
         <assert-deep-eq>'a', 'b', 'b', 'c', 'e', 'f'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-121">
      <description>Subscript is atomized, and untypedAtomic is converted to xs:integer</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XQ31+"/>
      <test><![CDATA[
        let $x := (<x>1</x>, <y>2</y>) return
        (['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?($x)
      ]]></test>
      <result>
         <assert-deep-eq>'a', 'b', 'b', 'c', 'e', 'f'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-122">
      <description>Double-flattening a sequence of arrays using ?*?*</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b']]?*?*</test>
      <result>
         <assert-deep-eq>'a', 'b', 'c', 'b', 'c', 'd', 'e', 'f', 'b'</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-123">
      <description>Select nothing from an array</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['a', 'b', 'c'], ['b', 'c', 'd'], ['e', 'f', 'b'])?()</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-140">
      <description>Lookup by name in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a':1, 'b':2, 'c':3},  map{'a':2, 'b':3, 'c':4})?b</test>
      <result>
         <assert-deep-eq>2, 3</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-141">
      <description>Lookup by number in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?2</test>
      <result>
         <assert-deep-eq>2, 3</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-142">
      <description>Lookup by range of values in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{2:3, 3:4, 4:5})?(1 to 2)</test>
      <result>
         <assert-deep-eq>1, 2, 3</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-143">
      <description>Lookup by hyphenated name in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})?c-1</test>
      <result>
         <assert-deep-eq>3, 4</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-144">
      <description>Comment appearing after "?"</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{'a-1':1, 'b-1':2, 'c-1':3},  map{'a-1':2, 'b-1':3, 'c-1':4})? (:confusing.?:) b-1</test>
      <result>
         <assert-deep-eq>2, 3</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-145">
      <description>Get all entries in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?*</test>
      <result>
         <assert-permutation>1, 2, 3, 2, 3, 4</assert-permutation>
      </result>
   </test-case>
   
   <test-case name="Lookup-146">
      <description>Select nothing from a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1:1, 2:2, 3:3},  map{1:2, 2:3, 3:4})?()</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-147">
      <description>Select from empty sequence</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>()?banana</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-148">
      <description>Select from empty sequence</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>()?12</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-149">
      <description>Select from empty sequence</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(())?(())</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-150">
      <description>Numeric Lookup followed by function call</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>[floor#1, ceiling#1, round#1, abs#1]?2(1.3)</test>
      <result>
         <assert-eq>2.0</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-151">
      <description>Name Lookup followed by function call</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?c(1.3)</test>
      <result>
         <assert-eq>2.0</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-152">
      <description>Parenthesized Lookup followed by function call</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?("c")(1.3)</test>
      <result>
         <assert-eq>2.0</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-153">
      <description>Parenthesized Lookup preceded by predicate</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}[1]?("c")(1.3)</test>
      <result>
         <assert-eq>2.0</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-154">
      <description>Wildcard Lookup followed by (mapped) function call</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <dependency type="feature" value="higherOrderFunctions"/>
      <test>map{'f':floor#1, 'c':ceiling#1, 'r':round#1, 'a':abs#1}?*!.(1.3)</test>
      <result>
         <assert-permutation>1.0, 2.0, 1.0, 1.3</assert-permutation>
      </result>
   </test-case>
   
   <test-case name="Lookup-155">
      <description>Lookup by name in a map; name is a keyword</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>map{'or':true(), 'and':true(), 'but':false()} ? or or 2 = 3</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="Lookup-156">
      <description>Lookup by name in a map; name is a QName</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>map{'xs:decimal':true(), 'xs:integer':true(), 'xs:polygon':false()} ? xs:integer</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-157">
      <description>Lookup by name in a map; name is an EQName</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>map{'decimal':true(), 'integer':true(), 'polygon':false()} ? Q{}integer</test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-158">
      <description>Double lookup into an array of maps</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[map{'decimal':true(), 'integer':true(), 'polygon':false()}, map{}] ?1?decimal</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="Lookup-159">
      <description>Double lookup into a map of arrays</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>map{'decimal':true(), 'integer':true(), 'polygon':[11,22,33]}?polygon?2</test>
      <result>
         <assert-eq>22</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-160">
      <description>Process all values in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>some $x in map{'decimal':true(), 'integer':true(), 'polygon':false()}?* satisfies $x</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="Lookup-161">
      <description>Process all values in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>count(map{'decimal':true(), 'integer':true(), 'polygon':false()}?*[.])</test>
      <result>
         <assert-eq>2</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-162">
      <description>Process all values in a map</description>
      <created by="Michael Kay" on="2014-11-27"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>max(map{'decimal':12, 'integer':18, 'polygon':-4}?*)</test>
      <result>
         <assert-eq>18</assert-eq>
      </result>
   </test-case>   
   
   <test-case name="Lookup-163">
      <description>Decimal literal not allowed for maps</description>
      <created by="Debbie Lockett" on="2015-07-17"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?2.2 </test>
      <result>
         <error code="XPST0003"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-164">
      <description>Decimal literal allowed in parentheses for maps</description>
      <created by="Debbie Lockett" on="2015-07-17"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(map{1.1:1, 2.2:2, 3.3:3},  map{1.1:2, 2.2:3, 3.3:4})?(2.2) </test>
      <result>
         <assert-deep-eq>2, 3</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-165">
      <description>Ensure that an operator symbol after binary "?" is parsed correctly</description>
      <created by="Michael Kay" on="2016-04-20"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $x := map{"div":18} return $x?div</test>
      <result>
         <assert-eq>18</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-166">
      <description>Ensure that an operator symbol after unary "?" is parsed correctly</description>
      <created by="Michael Kay" on="2016-04-20"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $x := map{"else":18} return exists($x[?else = 18])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   <test-case name="Lookup-167">
      <description>Ensure that a hyphenated name after binary "?" is parsed correctly</description>
      <created by="Michael Kay" on="2016-04-20"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $x := map{"div":81, "div-2":18} return $x?div-2</test>
      <result>
         <assert-eq>18</assert-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-168">
      <description>Ensure that a hyphenated name after unary "?" is parsed correctly</description>
      <created by="Michael Kay" on="2016-04-20"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $x := map{"else":81, "else-2":18} return exists($x[?else-2 = 18])</test>
      <result>
         <assert-true/>
      </result>
   </test-case>
   
   
   <!-- tests migrated from the ArrayTest test-set, and renamed s/ArrayTest-0xx/Lookup-2xx/ 2016-09-06 -->
   
   <test-case name="Lookup-211" covers="array-general">
      <description>key must be an integer value</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2015-11-26" change="add HOF dependency (dynamic function call)"/>
      <modified by="Debbie Lockett" on="2016-04-18" change="remove HOF dependency (dynamic function call allowed for arrays/maps)"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[1, 2, 3](1.1)</test>
      <result>
         <error code="XPTY0004"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-212" covers="postfix-lookup">
      <description>lookup outside of range</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="O'Neil Delpratt" on="2014-12-16" change="Bug fix relating #27180: Change error code" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[1, 2, 3]?0</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-213" covers="postfix-lookup">
      <description>lookup outside of range</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="O'Neil Delpratt" on="2014-12-16" change="Bug fix relating #27180: Change error code" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[1, 2, 3]?4</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-214" covers="array-general">
      <description>lookup key must be a positive integer</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="O'Neil Delpratt" on="2014-12-16" change="Bug fix relating #27180: Change error code" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[1, 2, 3](-1)</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>
   
   <test-case name="Lookup-215" covers="postfix-lookup">
      <description>lookup by using a parenthized expression</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>let $k := 2 to 3 return ['A', 'B', 'C']?($k)</test>
      <result>
         <assert-deep-eq>('B', 'C')</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-216" covers="postfix-lookup">
      <description>lookup by using a parenthized expression</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>['A', 'B', 'C']?(2 to 3)</test>
      <result>
         <assert-deep-eq>('B', 'C')</assert-deep-eq>
      </result>
   </test-case>
   
   <test-case name="Lookup-217" covers="postfix-lookup">
      <description>lookup by using *</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>['A', 'B', 'C']?*</test>
      <result>
         <assert-deep-eq>('A', 'B', 'C')</assert-deep-eq>
      </result>
   </test-case>   
   
   <test-case name="Lookup-218" covers="postfix-lookup fn-data">
      <description>lookup with nested arrays</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>fn:data([['A', 'B', 'C'], ['D', 'E'], []]?2)</test>
      <result>
         <assert-deep-eq>('D', 'E')</assert-deep-eq>
      </result>
   </test-case>   
   
   <test-case name="Lookup-219" covers="postfix-lookup fn-data">
      <description>lookup with nested arrays</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>fn:data([['A', 'B', 'C'], ['D', 'E'], []]?3)</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>   
   
   <test-case name="Lookup-220" covers="postfix-lookup">
      <description>multilevel lookup in nested arrays</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[['A', 'B', 'C'], ['D', 'E'], []]?1?2</test>
      <result>
         <assert-eq>'B'</assert-eq>
      </result>
   </test-case>   
   
   <test-case name="Lookup-221" covers="postfix-lookup fn-data">
      <description>multilevel wildcard lookup in nested arrays</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>fn:data([['A', 'B', 'C'], ['D', 'E'], []]?*?*)</test>
      <result>
         <assert-deep-eq>('A', 'B', 'C', 'D', 'E')</assert-deep-eq>
      </result>
   </test-case>  
   
   <test-case name="Lookup-222" covers="postfix-lookup">
      <description>wildcard lookup in empty array</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[]?*</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>
   
   <test-case name="Lookup-223" covers="postfix-lookup">
      <description>wildcard lookup in empty array</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[]?*?*</test>
      <result>
         <assert-empty/>
      </result>
   </test-case>   
   
   <test-case name="Lookup-224" covers="postfix-lookup">
      <description>lookup in empty array</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="O'Neil Delpratt" on="2014-12-16" change="Bug fix relating #27180: Change error code" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[]?2</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case>  
   
   
   <test-case name="Lookup-225" covers="postfix-lookup">
      <description>lookup in sequence of arrays</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['A', 'B', 'C'], ['D', 'E'])?2</test>
      <result>
         <assert-deep-eq>('B', 'E')</assert-deep-eq>
      </result>
   </test-case>      
   
   <test-case name="Lookup-226" covers="postfix-lookup">
      <description>lookup in sequence of arrays with empty array</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="O'Neil Delpratt" on="2014-12-16" change="Bug fix relating #27180: Change error code" />
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>(['A', 'B', 'C'], ['D', 'E'], [])?2</test>
      <result>
         <error code="FOAY0001"/>
      </result>
   </test-case> 
   
   <test-case name="Lookup-227" covers="postfix-lookup">
      <description>lookup in array with nested map</description>
      <created by="Carla Spruit" on="2014-10-28"/>
      <modified by="Michael Kay" on="2014-11-21" change="assert deep-eq rather than eq"/>
      <environment ref="map"/>
      <dependency type="spec" value="XP31+ XQ31+"/>
      <test>[[1, 2, 3], map:entry(3, 5)]?*?3</test>
      <result>
         <assert-deep-eq>(3, 5)</assert-deep-eq>
      </result>
   </test-case>            


</test-set>