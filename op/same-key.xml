<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="op-same-key" covers="op-same-key">
   <description>Tests for op:same-key</description>
   <link type="spec" document="http://www.w3.org/TR/xpath-functions-31/" idref="op-same-key"/>
   <dependency type="spec" value="XP31+ XQ31+ XT30+"/>

   <test-case name="same-key-001">
       <description>op:same-key over xs:string, xs:anyURI, and xs:untypedAtomic</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           map:merge((
              map:entry(xs:untypedAtomic("abc"), 1),
              map:entry(xs:string("abc"), 1),
              map:entry(xs:anyURI("abc"), 1),
              map:entry(xs:string("xyz"), 1),
              map:entry(xs:untypedAtomic("xyz"), 1),
              map:entry(QName((),"abc"), 1)
           ))
       </test>
       <result>
          <all-of>
             <assert>map:size($result) eq 3</assert>
             <assert>count(map:keys($result)) eq 3</assert>
             <assert>map:keys($result)[deep-equal(.,"abc")] instance of xs:anyURI</assert>
             <assert>map:keys($result)[deep-equal(.,"xyz")] instance of xs:untypedAtomic</assert>
             <assert>$result("abc") eq 1</assert>
          </all-of>
       </result>
   </test-case>

   <test-case name="same-key-002">
       <description>op:same-key should not use the default collation</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <dependency type="spec" value="XQ31+"/>    
       <test>
           declare default collation "http://www.w3.org/2005/xpath-functions/collation/html-ascii-case-insensitive";
           let $keys := ("ABC", "abc", "aBc")
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k
           ]
       </test>
       <result>
          <all-of>
             <assert>$result(1)=>map:size() eq 3</assert>
             <assert>$result(1)("abc") eq 2</assert>
             <assert>count($result(2)) eq 1</assert>
             <assert>count($result(3)) eq 1</assert>
          </all-of>
       </result>
   </test-case>

   <test-case name="same-key-003">
       <description>op:same-key over xs:string, xs:anyURI, and xs:untypedAtomic</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           map {
             "ab" || "c" : 1,
             xs:anyURI("abc") : 2
           }
       </test>
       <result>
           <error code="XQDY0137"/>
       </result>
   </test-case>
   
   <test-case name="same-key-004">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
            map:merge((
              map:entry(xs:double('NaN'), 1),
              map:entry(xs:double('INF'), 2),
              map:entry(xs:double('-INF'), 3),
              map:entry(xs:float('NaN'), 1),
              map:entry(xs:float('INF'), 2),
              map:entry(xs:float('-INF'), 3)
            ))
       </test>
       <result>
          <all-of>
             <assert>map:size($result) eq 3</assert>
             <assert>map:keys($result) instance of xs:float+</assert>
             <assert>$result(xs:double('NaN')) eq 1</assert>
             <assert>$result(xs:double('INF')) eq 2</assert>
             <assert>$result(xs:double('-INF')) eq 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-005">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
            map:merge((
              map:entry(xs:double('NaN'), 1),
              map:entry(xs:double('INF'), 2),
              map:entry(xs:double('-INF'), 3),
              map:entry(xs:float('NaN'), 1),
              map:entry(xs:float('INF'), 2),
              map:entry(xs:float('-INF'), 3)
            ))
       </test>
       <result>
          <all-of>
             <assert>map:size($result) eq 3</assert>
             <assert>map:keys($result) instance of xs:float+</assert>
             <assert>$result(xs:double('NaN')) eq 1</assert>
             <assert>$result(xs:double('INF')) eq 2</assert>
             <assert>$result(xs:double('-INF')) eq 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-006">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <dependency type="spec" value="XQ31+"/>    
       <test>
             let $keys := (
                 xs:decimal("1.00000000000000000000000000000000001"),
                 xs:decimal("1.00000000000000000000000000000000002"),
                 xs:double("1.0")
             )
             return [
                 map:merge($keys ! map:entry(., position())),
                 distinct-values($keys),
                 for $k in $keys group by $k return $k              
             ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:double("1.0") cast as xs:decimal) eq 3</assert>
             <assert>$result(1)(xs:double("1.0")) eq 3</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>   
   
   <test-case name="same-key-007">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
            map {
              xs:double("1.1") : 1
            }
       </test>
       <result>
          <all-of>
             <assert>$result(xs:decimal("1.1")) => empty()</assert>
             <assert>$result(1.1E0) eq 1</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-008">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
            map {
              1 div 3 cast as xs:float : "float",
              1 div 3 cast as xs:double : "double",
              1 div 3 cast as xs:integer : "integer"
            }
       </test>
       <result>
          <all-of>
             <assert>$result((1 div 3 cast as xs:float)   cast as xs:decimal) eq "float"</assert> 
             <assert>$result((1 div 3 cast as xs:double)  cast as xs:decimal) eq "double"</assert> 
             <assert>$result((1 div 3 cast as xs:integer) cast as xs:decimal) eq "integer"</assert> 
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-009">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           map { xs:integer("16777218") : 1 }
       </test>
       <result>
          <all-of>
             <assert>$result(16777218) eq 1</assert> 
             <assert>$result(xs:double("16777218")) eq 1</assert> 
             <assert>$result(xs:decimal("16777218")) eq 1</assert> 
          </all-of>
       </result>
   </test-case>      

   <test-case name="same-key-010">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           for $i in -100000 to 100000
           let $f := xs:float($i)
           let $m := map { $f : 1 }
           where not(map:contains($m, $f)) or
                 not(map:contains($m, $f cast as xs:decimal))
           return error((), "i=" || $i)
       </test>
       <result>
           <assert-empty/>
       </result>
   </test-case> 
   
   <test-case name="same-key-011">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           for $i in -100000 to 100000
           let $d := xs:double($i)
           let $m := map { $d : 1 }
           where not(map:contains($m, $d)) or
                 not(map:contains($m, $d cast as xs:decimal))
           return error((), "i=" || $i)
       </test>
       <result>
           <assert-empty/>
       </result>
   </test-case>
   
   <test-case name="same-key-012">
       <description>op:same-key over numerics</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           for $i in -100000 to 100000
           let $m := map { $i : 1 }
           where not(map:contains($m, $i)) or
                 not(map:contains($m, $i cast as xs:decimal))
           return error((), "i=" || $i)
       </test>
       <result>
           <assert-empty/>
       </result>
   </test-case>
   
   <test-case name="same-key-013">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $without_tz := xs:dateTime('2015-04-08T01:30:00') 
           let $with_tz := adjust-dateTime-to-timezone($without_tz, implicit-timezone())
           let $keys := (xs:dateTime('2015-04-08T02:30:00'), $without_tz, $with_tz)
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:dateTime('2015-04-08T02:30:00')) eq 1</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-014">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $without_tz := xs:date('2015-04-08') 
           let $with_tz := adjust-date-to-timezone($without_tz, implicit-timezone())
           let $keys := (xs:date('2015-04-09'), $without_tz, $with_tz)
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:date('2015-04-08')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-015">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $without_tz := xs:time('01:30:00') 
           let $with_tz := adjust-time-to-timezone($without_tz, implicit-timezone())
           let $keys := (xs:time('02:30:00'), $without_tz, $with_tz)
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:time('02:30:00')) eq 1</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-016">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $date := adjust-date-to-timezone(xs:date("2015-10-10"), implicit-timezone())
           let $keys := ($date cast as xs:gYear, xs:gYear("2015"), xs:gYear("2014"))
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:gYear('2015')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-017">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $date := adjust-date-to-timezone(xs:date("2015-10-10"), implicit-timezone())
           let $keys := ($date cast as xs:gYearMonth, xs:gYearMonth("2015-10"), xs:gYearMonth("2015-11"))
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:gYearMonth('2015-10')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-018">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $date := adjust-date-to-timezone(xs:date("2015-10-10"), implicit-timezone())
           let $keys := ($date cast as xs:gMonth, xs:gMonth("--10"), xs:gMonth("--11"))
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:gMonth('--10')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-019">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $date := adjust-date-to-timezone(xs:date("2015-10-10"), implicit-timezone())
           let $keys := ($date cast as xs:gMonthDay, xs:gMonthDay("--10-10"), xs:gMonthDay("--11-11"))
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:gMonthDay('--10-10')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-020">
       <description>op:same-key values with timezones</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
           let $date := adjust-date-to-timezone(xs:date("2015-10-10"), implicit-timezone())
           let $keys := ($date cast as xs:gDay, xs:gDay("---10"), xs:gDay("---11"))
           return [
               map:merge($keys ! map:entry(., position())),
               distinct-values($keys),
               for $k in $keys group by $k return $k             
           ]
       </test>
       <result>
          <all-of>
             <assert>map:size($result(1)) eq 3</assert>
             <assert>$result(1)(xs:gDay('---10')) eq 2</assert>
             <assert>count($result(2)) lt 3</assert>
             <assert>count($result(3)) lt 3</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-021">
       <description>op:same-key over xs:boolean, xs:hexBinary, xs:base64Binary, xs:duration, and xs:QName</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
            map {
               fn:true() : 1,
               fn:false() : 2,
               xs:hexBinary("ff") : 3,
               xs:base64Binary(xs:hexBinary("ff")) : 4,
               xs:duration("P12M") : 5,
               QName((), "abc") : 6,
               QName("http://example.org", "abc") : 7
            }
       </test>
       <result>
          <all-of>
             <assert>map:size($result) eq 7</assert>
             <assert>$result(fn:true()) eq 1</assert>
             <assert>$result(fn:false()) eq 2</assert>
             <assert>$result(xs:hexBinary("ff")) eq 3</assert>
             <assert>$result(xs:base64Binary(xs:hexBinary("ff"))) eq 4</assert>
             <assert>$result(xs:duration("P12M")) eq 5</assert>
             <assert>$result(QName((), "abc")) eq 6</assert>
             <assert>$result(QName("http://example.org", "abc")) eq 7</assert>
          </all-of>
       </result>
   </test-case>
   
   <test-case name="same-key-022">
       <description>op:same-key over xs:QName</description>
       <created by="Josh Spiegel" on="2015-07-22"/>
       <test>
          let $ns := "http://example.org"
          let $keys := (QName($ns, "foo"), QName($ns, "ns:foo"), QName($ns, "ns2:foo"))
          return
             map:merge($keys ! map:entry(., position()))
       </test>
       <result>
          <all-of>
              <assert>map:size($result) eq 1</assert>
              <assert>$result?(QName("http://example.org","foo")) eq 3</assert>
          </all-of>       
       </result>
   </test-case>
</test-set>