<?xml version="1.0" encoding="us-ascii"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="fn-transform" covers="fn-transform">
   <description/>
   <link type="spec" document="http://www.w3.org/TR/xpath-functions-31/"
         idref="func-transform"/>

   <dependency type="spec" value="XQ31+ XP31+"/>


   <environment name="works-mod-uri2">
      <source role="." file="../docs/works-mod.xml" uri="http://www.w3.org/fots/docs/works-mod.xml">
         <description>Data for various NIST tests (abbreviated, unabbreviated syntax)</description>
         <created by="Carmelo Montanez" on="2005-03-04"/>
      </source>
      <source file="transform/render.xsl" uri="http://www.w3.org/fots/fn/transform/render.xsl">
         <description>Stylesheet</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
      </source>
      <param name="uri" as="xs:string" select="'http://www.w3.org/fots/docs/works-mod.xml'" declared="false"/>
      <param name="render" as="xs:string" select="'http://www.w3.org/fots/fn/transform/render.xsl'" declared="false"/>
      <param name="base-uri" as="xs:string" select="'http://www.w3.org/fots/fn/transform/output-doc.xml'" declared="false"/>
   </environment>
    
    <environment name="works-mod-local">
        <source role="$works" file="../docs/works-mod.xml">
            <description>Data for various NIST tests (abbreviated, unabbreviated syntax)</description>
            <created by="Carmelo Montanez" on="2005-03-04"/>
        </source>        
        <source role="$render" file="transform/render.xsl">
            <description>Stylesheet</description>
            <created by="O'Neil Delpratt" on="2014-12-09"/>
        </source>
        <source role="$include" file="transform/include.xsl">
            <description>Stylesheet</description>
            <created by="Debbie Lockett" on="2015-03-09"/>
        </source>
    </environment>   

   <environment name="variable-uri">
      <source role="." file="transform/variable.xsl" uri="http://www.w3.org/fots/fn/transform/variable.xsl">
         <description>Stylesheet</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
      </source>
      <param name="variable-uri" as="xs:string" select="'http://www.w3.org/fots/fn/transform/variable.xsl'" declared="false"/>
   </environment>    
    
    

    <test-case name="fn-transform-1">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml, and uses an XPath expression to examine the result</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri)})return $result?output</test>
      <result>
         <assert>count($result//employee) > 0</assert>
      </result>
   </test-case>

    <test-case name="fn-transform-1a">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml. Delivery format set to xs:string</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Michael Kay" on="2015-01-03" change="change 'castable as' to 'instance of'"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized"})return $result?output instance of xs:string</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

   <test-case name="fn-transform-1b">
      <description>Loads a stylesheet from the location render.xsl, applies it to a document loaded from works-mod.xml. Delivery format set to document node (the default)</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Michael Kay" on="2015-01-03" change="change 'castable as' to 'instance of'"/>
       <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location"/>
      <environment ref="works-mod-uri2"/>
       <test>let $result := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document"})return $result?output instance of node()</test>
      <result>
         <assert-true/>
      </result>
   </test-case>

    <test-case name="fn-transform-2">
        <description>This test case demonstrates the ability to retrieve multiple result documents. Transform depends on XSLT 3.0 processor</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix options xslt-version and initial-template, typos in stylesheet, return statement and assertion"/>
        <dependency type="spec" value="XQ31+"/>
        <test>
            <![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'
                                                                 xmlns:app='http://www.example.com'>
                                                <xsl:template name='app:main' > <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}.html'>
                                                <xsl:value-of select='.' />
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";
                     declare variable $xml as xs:string := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   </doc>";

                    element{xs:QName('html')}{
                        element {xs:QName('body')} {
                            for $x in fn:transform(map{"xslt-version":3.0, "stylesheet-text":$xsl, "initial-template":fn:QName('http://www.example.com','main'), "source-node":fn:parse-xml($xml)})?*
                            return $x }
                        }]]>
        </test>
        <result>
           <assert>contains(string($result//body),'sect2')</assert>
        </result>
    </test-case>    
    
    <test-case name="fn-transform-3">
        <description>Use of stylesheet-params option</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix variable $in, use of fn:QName(), and result assertions; and change test-case description"/>
        <dependency type="spec" value="XQ31+"/>
        <environment ref="variable-uri"/>
        <test>
            <![CDATA[
                    let $in := parse-xml("<dummy/>")
                    let $style := doc($variable-uri) return (
                    transform(map{"source-node":$in, "stylesheet-node":$style, "stylesheet-params": map { QName("","v"): "2" } } ) )?output
                        ]]>
        </test>
        <result>
            <all-of>
                <assert>$result instance of node()</assert>
                <assert-xml><![CDATA[<v>2</v>]]></assert-xml>
            </all-of>            
        </result>
    </test-case>

    <test-case name="fn-transform-4">
        <description>Outputs the result as html, use of serialization-params</description>
        <created by="O'Neil Delpratt" on="2014-12-09"/>
        <modified by="Debbie Lockett" on="2015-03-05" change="Fix stylesheet, use of fn:QName(), and result assertion"/>
        <dependency type="spec" value="XQ31+"/>
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>")
let $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="html"/>
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "serialization-params": map{QName("","indent"): "yes"} } )?output]]>
        </test>
        <result>
            <assert>$result//b = 'XSLT'</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-5">
        <description>Outputs the result as html; input source and stylesheet as strings</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <dependency type="spec" value="XQ31+"/>
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>")
let $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:output method="html"/>
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        />
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style } )?output]]>
        </test>
        <result>
            <assert>$result//b = 'XSLT'</assert>
        </result>        
    </test-case>
    
    <test-case name="fn-transform-6">
        <description>Transform with minimal options: stylesheet-text, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>        
    </test-case>
    
    <test-case name="fn-transform-7">
        <description>Transform with minimal options: stylesheet-node, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-node":parse-xml($xsl), "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>        
    </test-case>
    
    <test-case name="fn-transform-8">
        <description>Transform with minimal options: stylesheet-node, source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            transform(map{"stylesheet-node":fn:parse-xml("<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>"), "source-node":parse-xml("<doc>this</doc>") })
        ]]></test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>        
    </test-case>
    
    <test-case name="fn-transform-9">
        <description>Transform using option initial-template</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template name='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-template": fn:QName('','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>    
    
    <test-case name="fn-transform-10">
        <description>Transform using option initial-template</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'
            xmlns:app='http://www.example.com'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template name='app:main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-template": fn:QName('http://www.example.com','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case> 
    
    <test-case name="fn-transform-11">
        <description>Transform using option initial-template, without source-node</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'
            xmlns:app='http://www.example.com'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template name='app:main'>
                    <out>that</out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "initial-template": fn:QName('http://www.example.com','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'that'</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-12">
        <description>Transform using option initial-mode</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
            <xsl:template match='/'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>
                <xsl:template match='/' mode='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-mode": fn:QName('','main') })
        ]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:contains($result, "output")</assert>
                <assert>$result("output") instance of node()</assert>
                <assert>$result?output//out = 'this'</assert>
            </all-of>
        </result>
    </test-case>   
    
    <test-case name="fn-transform-13">
        <description>Transform producing multiple result documents</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";
                    declare variable $xml as xs:string := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>";                                                   
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml)})]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section2")</assert>
            </all-of>     
        </result>
    </test-case>   
    
    <test-case name="fn-transform-14">
        <description>Transform producing multiple result documents, also uses base-output-uri option</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <environment name="multiple-result-docs">
            <source role="$multipledocs" file="transform/multipledocs.xsl"/>            
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections, "base-output-uri": "http://www.w3.org/fots/fn/transform/output-doc.xml"}) => map:keys()</test>
        <result>
            <assert-permutation>("http://www.w3.org/fots/fn/transform/section1.html","http://www.w3.org/fots/fn/transform/section2.html","http://www.w3.org/fots/fn/transform/section3.html")</assert-permutation>               
        </result> 
    </test-case>    
    
    <test-case name="fn-transform-15">
        <description>Transform using option stylesheet-params with multiple params</description>
        <created by="Debbie Lockett" on="2015-03-10"/>
        <dependency type="spec" value="XQ31+"/>
        <environment ref="variable-uri"/>
        <test>
            <![CDATA[
                    let $in := <dummy/>
                    let $style := "<xsl:stylesheet version='1.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                        <xsl:param name='v'/>
                        <xsl:param name='w'/>
                        <xsl:param name='x'/>
                        <xsl:param name='y'/>
                        <xsl:template match='dummy'>
                        <out>
                            <v><xsl:value-of select='$v'/></v>
                            <w><xsl:value-of select='$w'/></w>
                            <x><xsl:value-of select='$x'/></x>
                            <y><xsl:value-of select='$y'/></y>
                            </out>
                        </xsl:template>
                    </xsl:stylesheet>"
                    return (transform(map{"source-node":$in, "stylesheet-node":parse-xml($style), "stylesheet-params": map { QName("","v"): "2", QName("","w"): "3", QName("","y"): "5", QName("","x"): "4" } } ) )?output
            ]]>
        </test>
        <result>
            <all-of>
                <assert>$result instance of node()</assert>
                <assert-xml><![CDATA[<out><v>2</v><w>3</w><x>4</x><y>5</y></out>]]></assert-xml>
            </all-of>            
        </result>
    </test-case>
    
    <test-case name="fn-transform-16">
        <description>Transform using option base-output-uri</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document", "base-output-uri" : $base-uri})?($base-uri)</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-17">
        <description>Transform using option base-output-uri</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "document", "base-output-uri" : $base-uri})</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>map:contains($result, "http://www.w3.org/fots/fn/transform/output-doc.xml")</assert>
                <assert>$result("http://www.w3.org/fots/fn/transform/output-doc.xml") instance of node()</assert>
                <assert>count($result("http://www.w3.org/fots/fn/transform/output-doc.xml")//employee) > 0</assert>
            </all-of>
        </result>
    </test-case>   
    
    <test-case name="fn-transform-18">
        <description>Transform using options stylesheet-text and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:template name='main'>
                    <x><xsl:value-of select='static-base-uri()'/></x>
                    </xsl:template>
                    </xsl:stylesheet>";    
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})?output
            ]]></test>
        <result>
            <assert>$result/x = 'http://www.example.com'</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-19">
        <description>Transform using options stylesheet-node and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:template name='main'>
                    <x><xsl:value-of select='static-base-uri()'/></x>
                    </xsl:template>
                    </xsl:stylesheet>";    
            fn:transform(map {"stylesheet-node" : parse-xml($xsl), "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})?output
            ]]></test>
        <result>
            <assert>$result/x = 'http://www.example.com'</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-20">
        <description>Transform using options stylesheet-location and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-location" : 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl', "initial-template" : QName('','main'), "stylesheet-base-uri": "http://www.example.com"})?output</test>
        <result>
            <assert>$result/x = 'http://www.example.com'</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-21">
        <description>Transform using static base URI default from option stylesheet-location</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <environment>
            <source role="$staticbaseuri" file="transform/staticbaseuri.xsl"  uri="http://www.w3.org/fots/fn/transform/staticbaseuri.xsl"/>
        </environment>
        <test>fn:transform(map {"stylesheet-location" : "http://www.w3.org/fots/fn/transform/staticbaseuri.xsl", "initial-template" : QName('','main')})?output</test>
        <result>
            <assert>$result/x = 'http://www.w3.org/fots/fn/transform/staticbaseuri.xsl'</assert>
        </result>
    </test-case>    
    
    <test-case name="fn-transform-22">
        <description>Transform using xsl:include with relative href, using options stylesheet-text and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet version='2.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                    <xsl:include href='transform/staticbaseuri.xsl'/>
                    </xsl:stylesheet>";    
            fn:transform(map {"stylesheet-text" : $xsl, "initial-template" : QName('','main'), "stylesheet-base-uri": string(static-base-uri())})?output
            ]]></test>
        <result>
            <assert>contains($result/x,'fn/transform/staticbaseuri.xsl')</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-23">
        <description>Transform using xsl:include with relative href, using options stylesheet-node and stylesheet-base-uri</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $include, "source-node" : $works, "stylesheet-base-uri": string(base-uri($include))})?output</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-24">
        <description>Transform using xsl:include with relative href, with static base URI default from option stylesheet-node</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $include, "source-node" : $works})?output</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-25">
        <description>Transform using stylesheet-location (with a relative URI)</description>
        <created by="Debbie Lockett" on="2015-03-11"/>
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-location" : "transform/render.xsl", "source-node" : $works})?output</test>
        <result>
            <assert>count($result//employee) > 0</assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-26">
        <description>Transform using cache option true</description>
        <!-- Test attempts to check that caching has actually taken place, but fails to do so 
            (static variable is re-evaluated at run-time)  -->
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet version='3.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                <xsl:variable name='dateTime' static='yes' select='current-dateTime()'/>
                <xsl:template match='/'>
                    <x><xsl:value-of select='$dateTime'/></x>
                </xsl:template>
            </xsl:stylesheet>";  
            let $output1 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc1/>"), "cache":true()})?output//x
            let $output2 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc2/>")})?output//x
            return concat(string($output1), ' ', string($output2))
            ]]></test>
        <result>
            <assert>true()</assert> 
        </result>
    </test-case>
    
    <test-case name="fn-transform-27">
        <description>Transform using cache option false</description>
        <!-- Test attempts to check that caching has NOT actually taken place, but fails to do so 
            (static variable is re-evaluated at run-time)  -->
        <created by="Debbie Lockett" on="2015-03-11"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet version='3.0' xmlns:xsl='http://www.w3.org/1999/XSL/Transform'>
                <xsl:variable name='dateTime' static='yes' select='current-dateTime()'/>
                <xsl:template match='/'>
                    <x><xsl:value-of select='$dateTime'/></x>
                </xsl:template>
            </xsl:stylesheet>";  
            let $output1 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc1/>"), "cache":false()})?output//x
            let $output2 := fn:transform(map {"stylesheet-text" : $xsl, "source-node" : parse-xml("<doc2/>"), "cache":false()})?output//x
            return concat(string($output1), ' ', string($output2))
            ]]></test>
        <result>
            <assert>true()</assert> 
        </result>
    </test-case>
    
    <test-case name="fn-transform-28">
        <description>Transform using serialized delivery-format option, and serialization-params (no indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { QName("","indent"): "no" } })</test>
        <result>
            <all-of>
                <assert>$result?output instance of xs:string</assert> 
                <assert><![CDATA[contains($result?output, "<works>")]]></assert>
                <assert><![CDATA[contains($result?output, "</works>")]]></assert>
                <assert><![CDATA[contains($result?output, "<body><works>")]]></assert>
            </all-of>            
        </result>
    </test-case>   
    
    <test-case name="fn-transform-29">
        <description>Transform using serialized delivery-format option, and serialization-params (yes indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { QName("","indent"): "yes" } })</test>
        <result>
            <all-of>
                <assert>$result?output instance of xs:string</assert> 
                <assert><![CDATA[contains($result?output, "<works>")]]></assert>
                <assert><![CDATA[contains($result?output, "</works>")]]></assert>
                <assert><![CDATA[not(contains($result?output, "<body><works>"))]]></assert>
            </all-of>            
        </result>
    </test-case> 
    
    <test-case name="fn-transform-30">
        <description>Transforms using serialized delivery-format option, and serialization-params (yes and no indent)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <environment ref="works-mod-uri2"/>
        <test>let $out1 := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { QName("","indent"): "yes" } })?output,
            $out2 := fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri), "delivery-format" : "serialized",
            "serialization-params" : map { QName("","indent"): "no" } })?output
            return $out1 eq $out2
        </test>
        <result>
            <assert-false/>        
        </result>
    </test-case>
    
    <test-case name="fn-transform-31">
        <description>Transform using option serialization-params, to output result as html (with delivery-format serialized)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <dependency type="spec" value="XQ31+"/>
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>")
let $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "delivery-format":"serialized",
"serialization-params": map{QName("","method"): "html"} } )?output]]>
        </test>
        <result>
            <assert><![CDATA[contains($result, '<br>')]]></assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-32">
        <description>Transform using option serialization-params, to output result as xml (with delivery-format serialized)</description>
        <created by="Debbie Lockett" on="2015-03-13"/>
        <dependency type="spec" value="XQ31+"/>
        <test>
            <![CDATA[
                    let $in := xs:string("<books>
    <book>
        <title>XSLT Programmer?s Reference</title>
        <author>Michael H. Kay</author>
    </book>
    <book>
        <title>XSLT</title>
        <author>Doug Tidwell</author>
        <author>Simon St. Laurent</author>
        <author>Robert Romano</author>
    </book>
</books>")
let $style := xs:string('<xsl:stylesheet version="2.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
    <xsl:template match="/">
        <html>
            <body>
                <div>
                    <xsl:for-each select="books/book">
                        <b><xsl:value-of select="title"/></b>: <xsl:value-of select="author"
                        /><br/>
                    </xsl:for-each>
                </div>
            </body>
        </html>
    </xsl:template>
</xsl:stylesheet>')
return transform(map{"source-node":fn:parse-xml($in), "stylesheet-text":$style, "delivery-format":"serialized",
"serialization-params": map{QName("","method"): "xml"} } )?output]]>
        </test>
        <result>
            <assert><![CDATA[contains($result, '<br/>')]]></assert>
        </result>
    </test-case>
    
    <test-case name="fn-transform-33">
        <description>Transform producing multiple result documents, using serialized delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";
                    declare variable $xml as xs:string := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>";                                                   
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml), "delivery-format":"serialized"})]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section2")</assert>
            </all-of>     
        </result>
    </test-case>    
    
    <test-case name="fn-transform-34">
        <description>Transform using option base-output-uri, and saved delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment ref="works-mod-local"/>
        <test>fn:transform(map {"stylesheet-node" : $render, "source-node" : $works,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-34.xml", static-base-uri()),
            "delivery-format" : "saved"})?*</test>
        <result>
            <all-of>
                <assert>$result instance of xs:string</assert>
                <assert>contains($result, "fn-transform-34.xml")</assert>
                <assert>count(doc($result)//employee) > 3</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-35">
        <description>Transform using option base-output-uri, and saved delivery-format</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-35.xml", static-base-uri()),
            "delivery-format" : "saved"})</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(map:keys($result), 'fn-transform-35.xml')</assert>
                <assert>$result?* instance of xs:string</assert>
                <assert>contains($result?*, 'fn-transform-35.xml')</assert>
                <assert>count(doc('transform/sandbox/fn-transform-35.xml')//employee) > 3</assert>
                <assert>count(doc(map:keys($result))//employee) > 3</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key, 
                    'transform/sandbox/fn-transform-35.xml')</assert>
                <assert>some $key in map:keys($result) satisfies (
                    ends-with($key, 
                    'transform/sandbox/fn-transform-35.xml') and $result?($key) = $key)</assert>                
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-36">
        <description>Transform using saved delivery-format option, and serialization-params (yes
            indent)</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment ref="works-mod-uri2"/>
        <test>fn:transform(map {"stylesheet-location" : $render, "source-node" : fn:doc($uri),
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-36.xml", static-base-uri()),
            "delivery-format" : "saved", "serialization-params" : map { QName("","indent"): "yes" }
            })</test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 1</assert>
                <assert>ends-with(map:keys($result), 'transform/sandbox/fn-transform-36.xml')</assert>
                <assert>$result?* instance of xs:string</assert>
                <assert>ends-with($result?*, 'transform/sandbox/fn-transform-36.xml')</assert>
                <assert>count(doc(map:keys($result))//employee) > 3</assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-37">
        <description>Transform producing multiple result documents, using saved delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'>
                                                <xsl:template match='/'> <xsl:for-each select='//section'>
                                                <xsl:result-document href='section{position()}-page.html'> <!-- instructions content here -->
                                                    <html>
                                                        <body>
                                                            <h1>Section <xsl:value-of select='position()'/></h1>
                                                            <p>Some text here.</p>
                                                        </body>
                                                    </html>
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";
                    declare variable $xml as xs:string := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   <section>sect3</section>
                                                   </doc>";                                                   
            fn:transform(map {"stylesheet-text": $xsl, "source-node": parse-xml($xml), 
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-37/output.html", static-base-uri()),
            "delivery-format":"saved"})]]>
        </test>
        <result>
            <all-of>
                <assert-type>map(*)</assert-type>
                <assert>map:size($result) = 3</assert>
                <assert>not(map:contains($result, "output"))</assert>
                <assert>contains(string-join(map:keys($result)),"section1")</assert>
                <assert>some $key in map:keys($result) satisfies ends-with($key, 
                    'transform/sandbox/fn-transform-37/section3-page.html')</assert>
                <assert><![CDATA[some $key in map:keys($result) satisfies doc($key)//h1 = 'Section 2']]></assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-38">
        <description>Transform producing multiple result documents, using saved delivery-format and
            base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment name="multiple-result-docs">
            <source role="$multipledocs" file="transform/multipledocs.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs, "source-node":$sections,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-38/output.html",
            static-base-uri()), "delivery-format":"saved"}) => map:keys()</test>
        <result>
            <all-of>
                <assert>count($result) = 3</assert>
                <assert>contains(string-join($result), 'section1.html')</assert>
                <assert>some $key in $result satisfies ends-with($key, 
                    'transform/sandbox/fn-transform-38/section3.html')</assert>
                <assert><![CDATA[some $key in $result satisfies doc($key)//h1 = 'Header for section 2']]></assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-39">
        <description>Transform producing multiple result documents, using saved delivery-format
            option, but no base-output-uri (xsl:result-document/@href is absolute)</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment name="multiple-result-docs2">
            <source role="$multipledocs2" file="transform/multipledocs2.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node":$multipledocs2, "source-node":$sections,
            "delivery-format":"saved"}) => map:keys()</test>
        <result>
            <all-of>
                <assert>count($result) = 3</assert>
                <assert>contains(string-join($result), 'section1.html')</assert>
                <assert>some $key in $result satisfies ends-with($key, 
                    'transform/sandbox/fn-transform-39/section3.html')</assert>
                <assert><![CDATA[some $key in $result satisfies doc($key)//h1 = 'Header for section 2']]></assert>
            </all-of>
        </result>
    </test-case>
    
    <test-case name="fn-transform-40">
        <description>Transform producing one result document (as secondary result doc), using saved
            delivery-format and base-output-uri options</description>
        <created by="Debbie Lockett" on="2015-03-25"/>
        <environment name="onedoc">
            <source role="$onedoc" file="transform/onedoc.xsl"/>
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $onedoc, "source-node" : $sections,
            "base-output-uri" : resolve-uri("transform/sandbox/fn-transform-40/output.html",
            static-base-uri()), "delivery-format" : "saved"})</test>
        <result>
            <all-of>
                <assert>map:size($result) = 1</assert>
                <assert>ends-with($result?*, 'transform/sandbox/fn-transform-40/section1.html')</assert>
                <assert>ends-with(map:keys($result), 'transform/sandbox/fn-transform-40/section1.html')</assert>
                <assert><![CDATA[doc('transform/sandbox/fn-transform-40/section1.html')//h1 = 'Header for section 1']]></assert>
            </all-of>
        </result>
    </test-case>
    
    

    <test-case name="fn-transform-err-1">
      <description>Loads a stylesheet from the location render.xsl, but fails to supply a source document</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
      <modified by="Debbie Lockett" on="2015-03-05" change="Rename stylesheet-uri as stylesheet-location; change expected error"></modified>
      <environment ref="works-mod-uri2"/>
      <test>let $result := fn:transform(map {"stylesheet-location" : $render})return $result?output</test>
      <result>
         <error code="FOXT0002"/>
      </result>
   </test-case>

     <test-case name="fn-transform-err-2">
         <description>Error test case to detect supplied parameters that are mutually exclusive (stylesheet-text and stylesheet-location)</description>
         <created by="O'Neil Delpratt" on="2014-12-09"/>
         <dependency type="spec" value="XQ31+"/>
         <environment ref="works-mod-uri2"/>
      <test><![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'
                                                                 xmlns:app='http://www.example.com'>
                                                <xsl:template name='app:main' > <xsl:for-each select='section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";
                    declare variable $xml as xs:string := "<doc>
                                                   <section>sect1</section>
                                                   <section>sect2</section>
                                                   </doc>";

            let $result := fn:transform(map {"stylesheet-text": $xsl,"stylesheet-location" : $render, "source-node":fn:parse-xml($xml)})return $result?output]]>
      </test>
      <result>
         <error code="FOXT0002"/>
      </result>
   </test-case>

     <test-case name="fn-transform-err-3">
      <description>Error test case to detect supplied parameters that are mutually exclusive (stylesheet-text and stylesheet-node)</description>
      <created by="O'Neil Delpratt" on="2014-12-09"/>
         <dependency type="spec" value="XQ31+"/>
         <environment ref="works-mod-uri2"/>
      <test><![CDATA[
                    declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='3.0'
                                                                 xmlns:app='http://www.example.com'>
                                                <xsl:template name='app:main' > <xsl:for-each select='section'>
                                                <xsl:result-document href='section{position()}.html'> <!-- instructions content here -->
                                                </xsl:result-document> </xsl:for-each>
                                                </xsl:template> </xsl:stylesheet>";

            let $result := fn:transform(map {"stylesheet-text": $xsl,"stylesheet-node" : fn:doc($render), "source-node" : fn:doc($uri)})return $result?output]]>
      </test>
      <result>
         <error code="FOXT0002"/>
      </result>
   </test-case>
    
    <test-case name="fn-transform-err-4">
        <description>Error - the type of the value supplied for the option 'xslt-version' is incorrect</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "xslt-version":"2.0" })
        ]]></test>
        <result>
            <error code="FOXT0002"/>
        </result>       
    </test-case>
    
    <test-case name="fn-transform-err-5">
        <description>Error - the type of the value supplied for the option 'stylesheet-params' is incorrect</description>
        <created by="Debbie Lockett" on="2015-03-05"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
                <xsl:template match='/'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "stylesheet-params":"v" })
        ]]></test>
        <result>
            <error code="FOXT0002"/>
        </result>       
    </test-case>
    
    <test-case name="fn-transform-err-6">
        <description>Error test case to detect supplied parameters that are mutually exclusive (initial-mode and initial-template)</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <dependency type="spec" value="XQ31+"/>
        <test><![CDATA[
            declare variable $xsl as xs:string :="<xsl:stylesheet xmlns:xsl='http://www.w3.org/1999/XSL/Transform' version='2.0'>
            <xsl:template name='start'>
                <x><xsl:value-of select='.' /></x>
            </xsl:template>            
                <xsl:template match='/' mode='main'>
                    <out>
                        <xsl:value-of select='.' />
                    </out>
                </xsl:template> 
            </xsl:stylesheet>";
            transform(map{"stylesheet-text":$xsl, "source-node":parse-xml("<doc>this</doc>"), "initial-mode": fn:QName('','main'), "initial-template": fn:QName('','start') })
        ]]>
        </test>
        <result>
            <error code="FOXT0002"/>
        </result> 
    </test-case>   
    
    <test-case name="fn-transform-err-7">
        <description>Error - transform must have some options (at least one stylesheet and one source option)</description>
        <created by="Debbie Lockett" on="2015-03-03"/>
        <test>transform(map{})</test>
        <result>
            <error code="FOXT0002"/>
        </result> 
    </test-case>    
    
    <test-case name="fn-transform-err-8"> 
        <description>Error - value supplied for option base-output-uri should be absolute</description>
        <created by="Debbie Lockett" on="2015-03-09"/>
        <environment name="onedoc">
            <source role="$onedoc" file="transform/onedoc.xsl"/>            
            <source role="$sections" file="transform/sections.xml"/>
        </environment>
        <test>fn:transform(map {"stylesheet-node" : $onedoc, "source-node" : $sections, 
            "base-output-uri" : "fn/transform/output.xml", "delivery-format" : "saved"})?*</test>
        <result>
            <error code="FOXT0002"/>
        </result>
    </test-case>
    

</test-set>
