<?xml version="1.0" encoding="UTF-8"?>
<test-set xmlns="http://www.w3.org/2010/09/qt-fots-catalog" name="fn-map">
    <description>tests for the fn:map() higher-order function introduced in XPath 3.0</description>
    <link type="spec" document="http://www.w3.org/TR/xpath-functions-30/" idref="func-map"/>
    <dependency type="spec" value="XP30+ XQ30+"/>
    <environment name="names">
        <source xml:id="names" file="higherOrder/names.xml" >
            <description>Names of employees.</description>
            <created by="O'Neil Delpratt" on="2010-12-22"/>
        </source>
    </environment>
    <test-case name="map-001">
        <description>Convert names to upper-case (one-to-one mapping)</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(upper-case#1, ("aa", "bb", "cc", "dd", "ee"))</test>
        <result>
            <assert-deep-eq>"AA", "BB", "CC", "DD", "EE"</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-002">
        <description>Get lengths of names (one-to-many mapping)</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(string-to-codepoints#1, ("john", "jane"))</test>
        <result>
                <assert-deep-eq>106, 111, 104, 110, 106, 97, 110, 101</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-003">
        <description>Use map function as a filter</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(function($x){$x[contains(., 'e')]}, ("john", "mary", "jane", "anne", "peter", "ian"))</test>
        <result>
                <assert-deep-eq>"jane", "anne", "peter"</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-004">
        <description>Map using user-defined anonymous function</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(function($x){upper-case($x)} , ("john", "mary", "jane", "anne", "peter", "ian"))</test>
        <result>
                <assert-deep-eq>"JOHN", "MARY", "JANE", "ANNE", "PETER", "IAN"</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-005">
        <description>Map using user-defined anonymous function</description>
        <created by="Michael Kay" on="2010-02-10"/>
        <environment ref="names"/>
        <test>
            map(function($e as xs:string) as xs:string { lower-case($e) }, map(function($n as xs:string){upper-case($n)},("john", "mary", "jane", "anne", "peter", "ian")))
        </test>
        <result>
                <assert-deep-eq>"john", "mary", "jane", "anne", "peter", "ian"</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-006">
        <description>Map using a named recursive function</description>
        <created by="Michael Kay" on="2010-02-10"/>
        <environment>
            <source role="." file="higherOrder/doc1.xml"/>
        </environment>
        <dependency type="spec" value="XQ30+"/>
        <test>
            declare function local:children($n as node()) as node()* 
                { $n/child::node() }; 
            declare function local:attributes($e as node()) as node()* 
                { $e/attribute::node() }; 
            declare function local:self($e as node()) as node() 
                { $e }; 
            declare function local:union(
                        $f as function(node()) as node()*, 
                        $g as function(node()) as node()*) as function(node()) as node()* { 
                function($a) {$f($a) | $g($a)} };
            let $data := (/a), 
                $f := local:union(local:children#1, local:union(local:attributes#1, local:self#1)) 
            return map($f, $data/*)[not(. instance of attribute())]
        </test>
        <result>
            <assert-serialization>&lt;b bid="b"&gt;&lt;b1/&gt;&lt;/b&gt;&lt;b1/&gt;&lt;c cid="c"&gt;&lt;c1/&gt;&lt;/c&gt;&lt;c1/&gt;</assert-serialization>
        </result>
    </test-case>
    <test-case name="map-007">
        <description>map function - input is an empty sequence</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(round#1, ())</test>
        <result>
            <assert-empty />
        </result>
    </test-case>
    <test-case name="map-008">
        <description>map function - partial application</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>let $f := function($x as xs:double){map(round#1, $x)} return $f((1.2345, 6.789))</test>
        <result>
                <assert-deep-eq>1, 7</assert-deep-eq>
        </result>
    </test-case>
    <test-case name="map-901">
        <description>map function - error, function has the wrong arity</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(starts-with#2, ("aa", "bb", "cc", "dd", "ee"))</test>
        <result>
            <error code="XPTY0004"/>
        </result>
    </test-case>
    <test-case name="map-902">
        <description>map function - error, function can't handle one item in the sequence</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map(upper-case#1, ("aa", "bb", "cc", "dd", 12))</test>
        <result>
            <error code="XPTY0004"/>
        </result>
    </test-case>
    <test-case name="map-903">
        <description>map function - error, first argument is not a function</description>
        <created by="Michael Kay" on="2010-02-10"/>

        <test>map((), ("aa", "bb", "cc", "dd", 12))</test>
        <result>
            <error code="XPTY0004"/>
        </result>
    </test-case>
    
</test-set>
